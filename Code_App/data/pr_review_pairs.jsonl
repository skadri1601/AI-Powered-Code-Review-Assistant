{"repo": "psf/requests", "pr_number": 6767, "diff_hunk": "@@ -27,7 +27,6 @@\n from urllib3.util import Timeout as TimeoutSauce\n from urllib3.util import parse_url\n from urllib3.util.retry import Retry\n-from urllib3.util.ssl_ import create_urllib3_context\n \n from .auth import _basic_auth_str\n from .compat import basestring, urlparse\n", "review_comment": "This is one piece I left in place from #6667. We were unilaterally considering any `verify` string to be `ca_certs` instead of detecting if it was a directory. That seems like a miss from #6655 unless I'm missing something?"}
{"repo": "psf/requests", "pr_number": 6767, "diff_hunk": "@@ -74,19 +73,6 @@ def SOCKSProxyManager(*args, **kwargs):\n DEFAULT_POOL_TIMEOUT = None\n \n \n-try:\n-    import ssl  # noqa: F401\n-\n-    _preloaded_ssl_context = create_urllib3_context()\n-    _preloaded_ssl_context.load_verify_locations(\n-        extract_zipped_paths(DEFAULT_CA_BUNDLE_PATH)\n-    )\n-except ImportError:\n-    # Bypass default SSLContext creation when Python\n-    # interpreter isn't built with the ssl module.\n-    _preloaded_ssl_context = None\n-\n-\n def _urllib3_request_context(\n     request: \"PreparedRequest\",\n     verify: \"bool | str | None\",\n", "review_comment": "This is one piece I left in place from #6667. We were unilaterally considering any `verify` string to be `ca_certs` instead of detecting if it was a directory. That seems like a miss from #6655 unless I'm missing something?"}
{"repo": "psf/requests", "pr_number": 6767, "diff_hunk": "@@ -99,19 +85,9 @@ def _urllib3_request_context(\n     scheme = parsed_request_url.scheme.lower()\n     port = parsed_request_url.port\n \n-    # Determine if we have and should use our default SSLContext\n-    # to optimize performance on standard requests.\n-    poolmanager_kwargs = getattr(poolmanager, \"connection_pool_kw\", {})\n-    has_poolmanager_ssl_context = poolmanager_kwargs.get(\"ssl_context\")\n-    should_use_default_ssl_context = (\n-        _preloaded_ssl_context is not None and not has_poolmanager_ssl_context\n-    )\n-\n     cert_reqs = \"CERT_REQUIRED\"\n     if verify is False:\n         cert_reqs = \"CERT_NONE\"\n-    elif verify is True and should_use_default_ssl_context:\n-        pool_kwargs[\"ssl_context\"] = _preloaded_ssl_context\n     elif isinstance(verify, str):\n         if not os.path.isdir(verify):\n             pool_kwargs[\"ca_certs\"] = verify\n", "review_comment": "This is one piece I left in place from #6667. We were unilaterally considering any `verify` string to be `ca_certs` instead of detecting if it was a directory. That seems like a miss from #6655 unless I'm missing something?"}
{"repo": "psf/requests", "pr_number": 6767, "diff_hunk": "@@ -314,26 +290,27 @@ def cert_verify(self, conn, url, verify, cert):\n         :param cert: The SSL certificate to verify.\n         \"\"\"\n         if url.lower().startswith(\"https\") and verify:\n-            conn.cert_reqs = \"CERT_REQUIRED\"\n+            cert_loc = None\n \n-            # Only load the CA certificates if 'verify' is a string indicating the CA bundle to use.\n-            # Otherwise, if verify is a boolean, we don't load anything since\n-            # the connection will be using a context with the default certificates already loaded,\n-            # and this avoids a call to the slow load_verify_locations()\n+            # Allow self-specified cert location.\n             if verify is not True:\n-                # `verify` must be a str with a path then\n                 cert_loc = verify\n \n-                if not os.path.exists(cert_loc):\n-                    raise OSError(\n-                        f\"Could not find a suitable TLS CA certificate bundle, \"\n-                        f\"invalid path: {cert_loc}\"\n-                    )\n+            if not cert_loc:\n+                cert_loc = extract_zipped_paths(DEFAULT_CA_BUNDLE_PATH)\n \n-                if not os.path.isdir(cert_loc):\n-                    conn.ca_certs = cert_loc\n-                else:\n-                    conn.ca_cert_dir = cert_loc\n+            if not cert_loc or not os.path.exists(cert_loc):\n+                raise OSError(\n+                    f\"Could not find a suitable TLS CA certificate bundle, \"\n+                    f\"invalid path: {cert_loc}\"\n+                )\n+\n+            conn.cert_reqs = \"CERT_REQUIRED\"\n+\n+            if not os.path.isdir(cert_loc):\n+                conn.ca_certs = cert_loc\n+            else:\n+                conn.ca_cert_dir = cert_loc\n         else:\n             conn.cert_reqs = \"CERT_NONE\"\n             conn.ca_certs = None\n", "review_comment": "This is one piece I left in place from #6667. We were unilaterally considering any `verify` string to be `ca_certs` instead of detecting if it was a directory. That seems like a miss from #6655 unless I'm missing something?"}
{"repo": "psf/requests", "pr_number": 6876, "diff_hunk": "@@ -44,6 +44,16 @@ set with `headers=`.\n If credentials for the hostname are found, the request is sent with HTTP Basic\n Auth.\n \n+Requests will search for the netrc file at `~/.netrc`, `~/_netrc`, or at the path\n+specified by the `NETRC` environment variable. `~` denotes the user's home\n+directory, which is `$HOME` on Unix based systems and `%USERPROFILE%` on Windows.\n+\n+Usage of netrc file can be disabled by setting `trust_env` to `False` in the\n+Requests session::\n+\n+    >>> s = requests.Session()\n+    >>> s.trust_env = False\n+    >>> s.get('https://httpbin.org/basic-auth/user/pass')\n \n Digest Authentication\n ---------------------\n", "review_comment": "This doesn't list the Windows paths or how to disable this altogether."}
{"repo": "psf/requests", "pr_number": 6876, "diff_hunk": "@@ -222,6 +222,7 @@ Note: Custom headers are given less precedence than more specific sources of inf\n   are specified in ``.netrc``, which in turn will be overridden by the  ``auth=``\n   parameter. Requests will search for the netrc file at `~/.netrc`, `~/_netrc`,\n   or at the path specified by the `NETRC` environment variable.\n+  Check details in :ref:`netrc authentication <authentication>`.\n * Authorization headers will be removed if you get redirected off-host.\n * Proxy-Authorization headers will be overridden by proxy credentials provided in the URL.\n * Content-Length headers will be overridden when we can determine the length of the content.\n", "review_comment": "This doesn't list the Windows paths or how to disable this altogether."}
{"repo": "psf/requests", "pr_number": 6876, "diff_hunk": "@@ -44,6 +44,16 @@ set with `headers=`.\n If credentials for the hostname are found, the request is sent with HTTP Basic\n Auth.\n \n+Requests will search for the netrc file at `~/.netrc`, `~/_netrc`, or at the path\n+specified by the `NETRC` environment variable. `~` denotes the user's home\n+directory, which is `$HOME` on Unix based systems and `%USERPROFILE%` on Windows.\n+\n+Usage of netrc file can be disabled by setting `trust_env` to `False` in the\n+Requests session::\n+\n+    >>> s = requests.Session()\n+    >>> s.trust_env = False\n+    >>> s.get('https://httpbin.org/basic-auth/user/pass')\n \n Digest Authentication\n ---------------------\n", "review_comment": "@sigmavirus24 please check updated commit."}
{"repo": "psf/requests", "pr_number": 6876, "diff_hunk": "@@ -222,6 +222,7 @@ Note: Custom headers are given less precedence than more specific sources of inf\n   are specified in ``.netrc``, which in turn will be overridden by the  ``auth=``\n   parameter. Requests will search for the netrc file at `~/.netrc`, `~/_netrc`,\n   or at the path specified by the `NETRC` environment variable.\n+  Check details in :ref:`netrc authentication <authentication>`.\n * Authorization headers will be removed if you get redirected off-host.\n * Proxy-Authorization headers will be overridden by proxy credentials provided in the URL.\n * Content-Length headers will be overridden when we can determine the length of the content.\n", "review_comment": "@sigmavirus24 please check updated commit."}
{"repo": "psf/requests", "pr_number": 6710, "diff_hunk": "@@ -9,6 +9,7 @@\n import os.path\n import socket  # noqa: F401\n import typing\n+import warnings\n \n from urllib3.exceptions import ClosedPoolError, ConnectTimeoutError\n from urllib3.exceptions import HTTPError as _HTTPError\n", "review_comment": "If this method is deprecated shall we start emitting `DeprecationWarning`?"}
{"repo": "psf/requests", "pr_number": 6710, "diff_hunk": "@@ -374,10 +375,20 @@ def build_response(self, req, resp):\n \n         return response\n \n-    def _get_connection(self, request, verify, proxies=None, cert=None):\n-        # Replace the existing get_connection without breaking things and\n-        # ensure that TLS settings are considered when we interact with\n-        # urllib3 HTTP Pools\n+    def get_connection_with_tls_context(self, request, verify, proxies=None, cert=None):\n+        \"\"\"Returns a urllib3 connection for the given request and TLS settings.\n+        This should not be called from user code, and is only exposed for use\n+        when subclassing the :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.\n+\n+        :param request: The :class:`PreparedRequest <PreparedRequest>` object\n+            to be sent over the connection.\n+        :param verify: Either a boolean, in which case it controls whether\n+            we verify the server's TLS certificate, or a string, in which case it\n+            must be a path to a CA bundle to use.\n+        :param proxies: (optional) The proxies dictionary to apply to the request.\n+        :param cert: (optional) Any user-provided SSL certificate to be trusted.\n+        :rtype: urllib3.ConnectionPool\n+        \"\"\"\n         proxy = select_proxy(request.url, proxies)\n         try:\n             host_params, pool_kwargs = _urllib3_request_context(request, verify, cert)\n", "review_comment": "If this method is deprecated shall we start emitting `DeprecationWarning`?"}
{"repo": "psf/requests", "pr_number": 6710, "diff_hunk": "@@ -404,7 +415,10 @@ def _get_connection(self, request, verify, proxies=None, cert=None):\n         return conn\n \n     def get_connection(self, url, proxies=None):\n-        \"\"\"Returns a urllib3 connection for the given URL. This should not be\n+        \"\"\"DEPRECATED: Users should move to `get_connection_with_tls_context`\n+        for all subclasses of HTTPAdapter using Requests>=2.32.2.\n+\n+        Returns a urllib3 connection for the given URL. This should not be\n         called from user code, and is only exposed for use when subclassing the\n         :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.\n \n", "review_comment": "If this method is deprecated shall we start emitting `DeprecationWarning`?"}
{"repo": "psf/requests", "pr_number": 6710, "diff_hunk": "@@ -412,6 +426,15 @@ def get_connection(self, url, proxies=None):\n         :param proxies: (optional) A Requests-style dictionary of proxies used on this request.\n         :rtype: urllib3.ConnectionPool\n         \"\"\"\n+        warnings.warn(\n+            (\n+                \"`get_connection` has been deprecated in favor of \"\n+                \"`get_connection_with_tls_context`. Custom HTTPAdapter subclasses \"\n+                \"will need to migrate for Requests>=2.32.2. Please see \"\n+                \"https://github.com/psf/requests/pull/6710 for more details.\"\n+            ),\n+            DeprecationWarning,\n+        )\n         proxy = select_proxy(url, proxies)\n \n         if proxy:\n", "review_comment": "If this method is deprecated shall we start emitting `DeprecationWarning`?"}
{"repo": "psf/requests", "pr_number": 6710, "diff_hunk": "@@ -529,7 +552,9 @@ def send(\n         \"\"\"\n \n         try:\n-            conn = self._get_connection(request, verify, proxies=proxies, cert=cert)\n+            conn = self.get_connection_with_tls_context(\n+                request, verify, proxies=proxies, cert=cert\n+            )\n         except LocationValueError as e:\n             raise InvalidURL(e, request=request)\n \n", "review_comment": "If this method is deprecated shall we start emitting `DeprecationWarning`?"}
{"repo": "psf/requests", "pr_number": 6710, "diff_hunk": "@@ -9,6 +9,7 @@\n import os.path\n import socket  # noqa: F401\n import typing\n+import warnings\n \n from urllib3.exceptions import ClosedPoolError, ConnectTimeoutError\n from urllib3.exceptions import HTTPError as _HTTPError\n", "review_comment": "I thought about that but it's not reachable in any of our code anymore and if someone is using a custom implementation it won't have the warning.\n\nHappy to be wrong if I'm missing something but it seems like it will just be dead code on arrival."}
{"repo": "psf/requests", "pr_number": 6710, "diff_hunk": "@@ -374,10 +375,20 @@ def build_response(self, req, resp):\n \n         return response\n \n-    def _get_connection(self, request, verify, proxies=None, cert=None):\n-        # Replace the existing get_connection without breaking things and\n-        # ensure that TLS settings are considered when we interact with\n-        # urllib3 HTTP Pools\n+    def get_connection_with_tls_context(self, request, verify, proxies=None, cert=None):\n+        \"\"\"Returns a urllib3 connection for the given request and TLS settings.\n+        This should not be called from user code, and is only exposed for use\n+        when subclassing the :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.\n+\n+        :param request: The :class:`PreparedRequest <PreparedRequest>` object\n+            to be sent over the connection.\n+        :param verify: Either a boolean, in which case it controls whether\n+            we verify the server's TLS certificate, or a string, in which case it\n+            must be a path to a CA bundle to use.\n+        :param proxies: (optional) The proxies dictionary to apply to the request.\n+        :param cert: (optional) Any user-provided SSL certificate to be trusted.\n+        :rtype: urllib3.ConnectionPool\n+        \"\"\"\n         proxy = select_proxy(request.url, proxies)\n         try:\n             host_params, pool_kwargs = _urllib3_request_context(request, verify, cert)\n", "review_comment": "I thought about that but it's not reachable in any of our code anymore and if someone is using a custom implementation it won't have the warning.\n\nHappy to be wrong if I'm missing something but it seems like it will just be dead code on arrival."}
{"repo": "psf/requests", "pr_number": 6710, "diff_hunk": "@@ -404,7 +415,10 @@ def _get_connection(self, request, verify, proxies=None, cert=None):\n         return conn\n \n     def get_connection(self, url, proxies=None):\n-        \"\"\"Returns a urllib3 connection for the given URL. This should not be\n+        \"\"\"DEPRECATED: Users should move to `get_connection_with_tls_context`\n+        for all subclasses of HTTPAdapter using Requests>=2.32.2.\n+\n+        Returns a urllib3 connection for the given URL. This should not be\n         called from user code, and is only exposed for use when subclassing the\n         :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.\n \n", "review_comment": "I thought about that but it's not reachable in any of our code anymore and if someone is using a custom implementation it won't have the warning.\n\nHappy to be wrong if I'm missing something but it seems like it will just be dead code on arrival."}
{"repo": "psf/requests", "pr_number": 6710, "diff_hunk": "@@ -412,6 +426,15 @@ def get_connection(self, url, proxies=None):\n         :param proxies: (optional) A Requests-style dictionary of proxies used on this request.\n         :rtype: urllib3.ConnectionPool\n         \"\"\"\n+        warnings.warn(\n+            (\n+                \"`get_connection` has been deprecated in favor of \"\n+                \"`get_connection_with_tls_context`. Custom HTTPAdapter subclasses \"\n+                \"will need to migrate for Requests>=2.32.2. Please see \"\n+                \"https://github.com/psf/requests/pull/6710 for more details.\"\n+            ),\n+            DeprecationWarning,\n+        )\n         proxy = select_proxy(url, proxies)\n \n         if proxy:\n", "review_comment": "I thought about that but it's not reachable in any of our code anymore and if someone is using a custom implementation it won't have the warning.\n\nHappy to be wrong if I'm missing something but it seems like it will just be dead code on arrival."}
{"repo": "psf/requests", "pr_number": 6710, "diff_hunk": "@@ -529,7 +552,9 @@ def send(\n         \"\"\"\n \n         try:\n-            conn = self._get_connection(request, verify, proxies=proxies, cert=cert)\n+            conn = self.get_connection_with_tls_context(\n+                request, verify, proxies=proxies, cert=cert\n+            )\n         except LocationValueError as e:\n             raise InvalidURL(e, request=request)\n \n", "review_comment": "I thought about that but it's not reachable in any of our code anymore and if someone is using a custom implementation it won't have the warning.\n\nHappy to be wrong if I'm missing something but it seems like it will just be dead code on arrival."}
{"repo": "psf/requests", "pr_number": 6710, "diff_hunk": "@@ -9,6 +9,7 @@\n import os.path\n import socket  # noqa: F401\n import typing\n+import warnings\n \n from urllib3.exceptions import ClosedPoolError, ConnectTimeoutError\n from urllib3.exceptions import HTTPError as _HTTPError\n", "review_comment": "I guess it's better to be safe, this should be addressed in 92075b330a30b9883f466a43d3f7566ab849f91b."}
{"repo": "psf/requests", "pr_number": 6710, "diff_hunk": "@@ -374,10 +375,20 @@ def build_response(self, req, resp):\n \n         return response\n \n-    def _get_connection(self, request, verify, proxies=None, cert=None):\n-        # Replace the existing get_connection without breaking things and\n-        # ensure that TLS settings are considered when we interact with\n-        # urllib3 HTTP Pools\n+    def get_connection_with_tls_context(self, request, verify, proxies=None, cert=None):\n+        \"\"\"Returns a urllib3 connection for the given request and TLS settings.\n+        This should not be called from user code, and is only exposed for use\n+        when subclassing the :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.\n+\n+        :param request: The :class:`PreparedRequest <PreparedRequest>` object\n+            to be sent over the connection.\n+        :param verify: Either a boolean, in which case it controls whether\n+            we verify the server's TLS certificate, or a string, in which case it\n+            must be a path to a CA bundle to use.\n+        :param proxies: (optional) The proxies dictionary to apply to the request.\n+        :param cert: (optional) Any user-provided SSL certificate to be trusted.\n+        :rtype: urllib3.ConnectionPool\n+        \"\"\"\n         proxy = select_proxy(request.url, proxies)\n         try:\n             host_params, pool_kwargs = _urllib3_request_context(request, verify, cert)\n", "review_comment": "I guess it's better to be safe, this should be addressed in 92075b330a30b9883f466a43d3f7566ab849f91b."}
{"repo": "psf/requests", "pr_number": 6710, "diff_hunk": "@@ -404,7 +415,10 @@ def _get_connection(self, request, verify, proxies=None, cert=None):\n         return conn\n \n     def get_connection(self, url, proxies=None):\n-        \"\"\"Returns a urllib3 connection for the given URL. This should not be\n+        \"\"\"DEPRECATED: Users should move to `get_connection_with_tls_context`\n+        for all subclasses of HTTPAdapter using Requests>=2.32.2.\n+\n+        Returns a urllib3 connection for the given URL. This should not be\n         called from user code, and is only exposed for use when subclassing the\n         :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.\n \n", "review_comment": "I guess it's better to be safe, this should be addressed in 92075b330a30b9883f466a43d3f7566ab849f91b."}
{"repo": "psf/requests", "pr_number": 6710, "diff_hunk": "@@ -412,6 +426,15 @@ def get_connection(self, url, proxies=None):\n         :param proxies: (optional) A Requests-style dictionary of proxies used on this request.\n         :rtype: urllib3.ConnectionPool\n         \"\"\"\n+        warnings.warn(\n+            (\n+                \"`get_connection` has been deprecated in favor of \"\n+                \"`get_connection_with_tls_context`. Custom HTTPAdapter subclasses \"\n+                \"will need to migrate for Requests>=2.32.2. Please see \"\n+                \"https://github.com/psf/requests/pull/6710 for more details.\"\n+            ),\n+            DeprecationWarning,\n+        )\n         proxy = select_proxy(url, proxies)\n \n         if proxy:\n", "review_comment": "I guess it's better to be safe, this should be addressed in 92075b330a30b9883f466a43d3f7566ab849f91b."}
{"repo": "psf/requests", "pr_number": 6710, "diff_hunk": "@@ -529,7 +552,9 @@ def send(\n         \"\"\"\n \n         try:\n-            conn = self._get_connection(request, verify, proxies=proxies, cert=cert)\n+            conn = self.get_connection_with_tls_context(\n+                request, verify, proxies=proxies, cert=cert\n+            )\n         except LocationValueError as e:\n             raise InvalidURL(e, request=request)\n \n", "review_comment": "I guess it's better to be safe, this should be addressed in 92075b330a30b9883f466a43d3f7566ab849f91b."}
{"repo": "psf/requests", "pr_number": 6702, "diff_hunk": "@@ -37,3 +37,23 @@ jobs:\n     - name: Run tests\n       run: |\n         make ci\n+\n+  no_chardet:\n+    name: \"No Character Detection\"\n+    runs-on: ubuntu-latest\n+    strategy:\n+      fail-fast: true\n+\n+    steps:\n+      - uses: actions/checkout@8ade135a41bc03ea155e62e844d188df1ea18608\n+      - name: 'Set up Python 3.8'\n+        uses: actions/setup-python@82c7e631bb3cdc910f68e0081d67478d79c6982d\n+        with:\n+          python-version: '3.8'\n+      - name: Install dependencies\n+        run: |\n+          make\n+          python -m pip uninstall -y \"charset_normalizer\" \"chardet\"\n+      - name: Run tests\n+        run: |\n+          make ci\n", "review_comment": "While this keeps the logic of the earlier code, I think that the library which is required on should be tried first. https://github.com/psf/requests/pull/6714 addresses this."}
{"repo": "psf/requests", "pr_number": 6702, "diff_hunk": "@@ -83,7 +83,11 @@ def check_compatibility(urllib3_version, chardet_version, charset_normalizer_ver\n         # charset_normalizer >= 2.0.0 < 4.0.0\n         assert (2, 0, 0) <= (major, minor, patch) < (4, 0, 0)\n     else:\n-        raise Exception(\"You need either charset_normalizer or chardet installed\")\n+        warnings.warn(\n+            \"Unable to find acceptable character detection dependency \"\n+            \"(chardet or charset_normalizer).\",\n+            RequestsDependencyWarning,\n+        )\n \n \n def _check_cryptography(cryptography_version):\n", "review_comment": "While this keeps the logic of the earlier code, I think that the library which is required on should be tried first. https://github.com/psf/requests/pull/6714 addresses this."}
{"repo": "psf/requests", "pr_number": 6702, "diff_hunk": "@@ -7,13 +7,28 @@\n compatibility until the next major version.\n \"\"\"\n \n-try:\n-    import chardet\n-except ImportError:\n-    import charset_normalizer as chardet\n-\n+import importlib\n import sys\n \n+# -------------------\n+# Character Detection\n+# -------------------\n+\n+\n+def _resolve_char_detection():\n+    \"\"\"Find supported character detection libraries.\"\"\"\n+    chardet = None\n+    for lib in (\"chardet\", \"charset_normalizer\"):\n+        if chardet is None:\n+            try:\n+                chardet = importlib.import_module(lib)\n+            except ImportError:\n+                pass\n+    return chardet\n+\n+\n+chardet = _resolve_char_detection()\n+\n # -------\n # Pythons\n # -------\n", "review_comment": "While this keeps the logic of the earlier code, I think that the library which is required on should be tried first. https://github.com/psf/requests/pull/6714 addresses this."}
{"repo": "psf/requests", "pr_number": 6702, "diff_hunk": "@@ -789,7 +789,12 @@ def next(self):\n     @property\n     def apparent_encoding(self):\n         \"\"\"The apparent encoding, provided by the charset_normalizer or chardet libraries.\"\"\"\n-        return chardet.detect(self.content)[\"encoding\"]\n+        if chardet is not None:\n+            return chardet.detect(self.content)[\"encoding\"]\n+        else:\n+            # If no character detection library is available, we'll fall back\n+            # to a standard Python utf-8 str.\n+            return \"utf-8\"\n \n     def iter_content(self, chunk_size=1, decode_unicode=False):\n         \"\"\"Iterates over the response data.  When stream=True is set on the\n", "review_comment": "While this keeps the logic of the earlier code, I think that the library which is required on should be tried first. https://github.com/psf/requests/pull/6714 addresses this."}
{"repo": "psf/requests", "pr_number": 6702, "diff_hunk": "@@ -1,13 +1,6 @@\n import sys\n \n-try:\n-    import chardet\n-except ImportError:\n-    import warnings\n-\n-    import charset_normalizer as chardet\n-\n-    warnings.filterwarnings(\"ignore\", \"Trying to detect\", module=\"charset_normalizer\")\n+from .compat import chardet\n \n # This code exists for backwards compatibility reasons.\n # I don't like it either. Just look the other way. :)\n", "review_comment": "While this keeps the logic of the earlier code, I think that the library which is required on should be tried first. https://github.com/psf/requests/pull/6714 addresses this."}
{"repo": "psf/requests", "pr_number": 6702, "diff_hunk": "@@ -20,11 +13,11 @@\n         if mod == package or mod.startswith(f\"{package}.\"):\n             sys.modules[f\"requests.packages.{mod}\"] = sys.modules[mod]\n \n-target = chardet.__name__\n-for mod in list(sys.modules):\n-    if mod == target or mod.startswith(f\"{target}.\"):\n-        imported_mod = sys.modules[mod]\n-        sys.modules[f\"requests.packages.{mod}\"] = imported_mod\n-        mod = mod.replace(target, \"chardet\")\n-        sys.modules[f\"requests.packages.{mod}\"] = imported_mod\n-# Kinda cool, though, right?\n+if chardet is not None:\n+    target = chardet.__name__\n+    for mod in list(sys.modules):\n+        if mod == target or mod.startswith(f\"{target}.\"):\n+            imported_mod = sys.modules[mod]\n+            sys.modules[f\"requests.packages.{mod}\"] = imported_mod\n+            mod = mod.replace(target, \"chardet\")\n+            sys.modules[f\"requests.packages.{mod}\"] = imported_mod\n", "review_comment": "While this keeps the logic of the earlier code, I think that the library which is required on should be tried first. https://github.com/psf/requests/pull/6714 addresses this."}
